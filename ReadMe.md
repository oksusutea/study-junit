# 좋은 테스트의 FIRST 속성

* [F]ast : 빠른
* [I]solated : 고립된
* [R]epeatable : 반복가능한
* [S]elf-validating : 스스로 검증 가능한
* [T]imely : 적시의

### [F]IRST : 빠르다

빠른 테스트는 코드만 실행하며 소요시간은 수 밀리초 수준이다.  
DB등 영속성 저장소와 연관되어 있는 코드는 테스트 할 떄 수백밀리초까지 걸릴 수 있기 때문에, 이와 분리하여 빠르게 테스트를 수행할 수 있도록 테스트 코드를 작성해주어야 한다.

### F[I]RST : 고립시킨다

좋은 단위 테스트는 검증하려는 작은 양의 코드에 집중한다. 또한, 좋은 단위 테스트는 다른 단위 테스트에 의존하지 않는다.(혹은 같은 메서드에 있는 테스트 케이스)

### FI[R]ST : 좋은 테스트는 반복 가능해야 한다

반복 가능한 테스트는 실행할 때마다 결과가 같아야 한다. 만일 시간과 같이 통제할 수 없는 요소에 대해 테스트를 한다면? 진짜 시간을 가진 것 처럼 속이는 방법을 사용해보자.
(`java.time.Clock`을 사용한다)

### FIR[S]T : 스스로 검증 가능하다

`main()`메소드 같은 것을 사용하면 사용자가 결국 실행 한 값이 맞는지를 확인해주어야 한다. 스스로 검증하지 못하면 좋은 테스트라고 할 수 었다.

### FIRS[T] : 적시에 사용한다

단위 테스트를 많이 할 수록 테스트 대상 코드가 줄어든다. 그리고 새로운 코드를 넣었을 때 테스트 효과가 즉시 나타난다.

***

# Right-BICEP: 무엇을 테스트할 것인가?

* [Right]-BICEP: 결과가 올바른가?
* Right-[B]ICEP: 경계 조건은 맞는가?
* Right-B[I]CEP: 역 관계를 검사할 수 있는가?
* Right-BI[C]EP: 다른 수단을 활용하여 교차 검사할 수 있는가?
* Right-BIC[E]P: 오류 조건을 강제로 일어나게 할 수 있는가?
* Right-BICE[P]: 성능 조건은 기준에 부합하는가?

### [Right]-BICEP: 결과가 올바른가?

테스트 코드는 무엇보다도 먼저 기대한 결과를 산출하는지 검증 할 수 있어야 한다.  
단위테스트를 작성할때 결과 단언 값을 문서화하자. 어떤 변경이 발생하면, 적어도 현재까지 코드가 어떻게 동작했는지 알 수 있다.

### Right-[B]ICEP: 경계 조건은 맞는가? (boundary Conditions)

테스트 코드에서는 기능의 결과가 올바른 값을 산출하는지 검증하는 것도 중요하지만, courner case에 대해서도 오류가 적절하게 처리되는지 검증해야 한다.  
생각해야 하는 경계 조건은 아래와 같다 :

* 모호하고 일관성 없는 입력 값. 예를 들어 특수문자("!@#$%^)가 포함된 파일 이름
* 잘못된 양식의 데이터. 예를 들어 최상위 도메인이 빠진 이메일 주소 등(fred@foobar.)
* 수치적 오버플로를 일으키는 계산
* 비거나 빠진 값. 예를 들어 0, 0.0, "" 혹은 null
* 이성적인 기댓값을 훨씬 벗어나는 값. 예를 들어 나이가 160살일 경우
* 교실의 당번표처럼 중복을 허용해서는 안되는 목록에 중복 값이 있는 경우
* 정렬이 안된 정렬 리스트 혹은 그 반대. 정렬 알고리즘에 이미 정렬된 입력 값을 넣는 경우나, 정렬 알고리즘에 역순 데이터를 넣는 경우
* 시간 순이 맞지 않는 경우. 예를들어 HTTP 서버가 OPTIONS 메서드의 결과를 POST보다 먼저 반환해야 하지만, 그 후에 반환하는 경우

유호하지 않은 값을 넣자마자 오류가 발생하도록 하는 것이 좋다. 아래와 같이 말이다.

```java
public void add(Scoreable scoreable){
    if(scoreable==null){
    throw new IllegalArgumentException();
    }
    scores.add(scoreable);
    }
```

이런 경계 조건에서는 **CORRECT** 약어를 기억해 적절하게 처리해주자.

### Right-B[I]CEP: 역 관계를 검사할 수 있는가? (inverse relationship)

때때로 논리적인 역 관계를 적용하여 행동을 검사할 수 있다. 수학 계산에서 곱셈을 나눗셈으로 검증하고, 뺄셈으로 덧셈을 검증하는 것과 같이 말이다.

### Right-BI[C]EP: 다른 수단을 활용하여 교차 검사할 수 있는가? (cross-check)

우리가 개발을 할 때는 성능이 좋은 1등 해법을 선택하지만, 운영상에는 그 외 이슈로 선택하지 못한 알고리즘이 있을 수 있다. 이런 알고리즘은(운영상 적용되지 못했지만, 기능상
적용 가능한 것들) 교차검사할 때 활용할 수 있다. 교차 검사를 보는 다른 방법은, 클래스의 서로 다른 조각 데이터를 사용해 모든 데이터가 합산되는지 확인해 보는 것이다.

### Right-BIC[E]P: 오류 조건을 강제로 일어나게 할 수 있는가? (error conditions)

기능상의 예외가 발생하여 오류가 일어날 수도 있지만, 디스크가 꽉차거나 네트워크 선이 떨어지거나 등 각종 원인으로 인해 프로그램이 중단될 수 있다. 이러한 현상을 효과적으로
처리하기 위해 테스트에서도 오류를 강제로 발생시켜야 한다. 먼저 코드를 테스트하기 위해 도입할 수 있는 오류의 종류 혹은 다른 환경적 제약 사항을 생각해볼 떄, 아래 시나리오를
고려해볼 수 있다 :

* 메모리가 가득 찰 때
* 디스크 공간이 가득 찰 때
* 벽시계 시간(클라이언트 시간 != 서버 시간)에 관한 문제들
* 네트워크 가용성 및 오류
* 시스템 로드
* 제한된 색상 팔레트
* 매우 높거나 낮은 비디오 해상도

### Right-BICE[P]: 성능 조건은 기준에 부합하는가? (performance characteristics)

성능이 핵심 고려 사항이라면 단위 테스트보다는 좀 더 고수준에서 문제를 집중하고 싶을 것이고, JMeter 같은 도구를 사용해주는 것이 좋다.